---
layout: post
title: 'Pointer 指针'
date: 2020-02-24
author: Wen Jian
cover: ''
tags: C++ Pointer Basic
---

> 一些关于指针的温习与总结

### 关于指针

C语言里，变量存放在内存中，而内存其实就是一组连续的、由有序字节组成的数组，每个字节有唯一的内存地址。CPU 通过内存寻址对存储在内存中的某个指定数据对象的地址进行定位。这里，数据对象是指存储在内存中的一个指定数据类型的数值或字符串，它们都有一个自己的地址，而指针便是保存这个地址的变量。也就是说：**指针是一种保存变量地址的变量**。

### 声明与初始化

``` c++
int *p;//声明一个 int 类型的指针 p
char *p;//声明一个 char 类型的指针 p
int *arr[10];//声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向 int 类型对象的指针
int (*arr)[10];//声明一个数组指针，该指针指向一个 int 类型的一维数组
int **p;//声明一个指针 p ，该指针指向一个 int 类型的指针
```

在这些指针的初始化语句中，指针 p 和 arr 本身保存的其实是内存中某个变量的地址，当我们用到 \*p ，\*arr 时，我们访问的则是它们所指向的变量。

不过，当我们声明指针时，系统并不会为指针自动分配对应的内存，因此，我们需要对指针进行初始化：让它指向已有的内存，或是为它动态分配内存。

``` c++
/*方法1：使指针指向现有的内存*/
int x=1;
int *p=&x;//指针 p 被初始化，指向变量 x ，其中取地址符 & 用于产生操作数内存地址

/*方法2：动态分配内存给指针*/
int *p;
p=(int *)malloc(sizeof(int)*10);//malloc() 函数用于动态分配内存
free(p);//free() 函数用于释放一块已经分配的内存，常与 malloc() 函数一起使用，它们都被包含在<cstdlib>中
```

特殊地，我们还可以对指针进行这样的初始化：

``` c++
int *p=NULL;
```

这样p就是一个NULL指针，指向的内存地址为0。NULL 指针是一钟特殊的指针变量，表示不指向任何东西。在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明该指针不指向任何一个可访问的内存位置。

### 指针运算

指针只支持两种运算：+/-某个整数、指针相减。

#### +/-某个整数

可以对指针变量 p 进行 p++、p\-\-、p + i 等操作，所得结果也是一个指针，只是指针所指向的内存地址相比于 p 所指的内存地址前进或者后退了若干个操作数。

考虑到数组的连续性（悄悄告诉你，二维数组在内存中也是连续存储的哦~），这种运算特别适合与数组的访问与遍历。

#### 指针-指针

只有当两个指针都**指向同一个数组中的元素**时，才允许从一个指针减去另一个指针。两个指针相减的结果的类型是 ptrdiff_t ，它是一种有符号整数类型。减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位），因为减法运算的结果将除以数组元素类型的长度。也就是说，**指针-指针的运算结果就是指针各自所指元素的下标之差**。

### 指针与数组

关于数组这一块的指针，我觉得倒是相对简单了一些。还是主要提一下指针数组和数组指针。

#### 指针数组

指针是一个变量，而数组是用于存储变量的容器，因此，指针也可以像其他变量一样存储在数组中，也就是指针数组。 指针数组是一个数组，数组中的每一个元素都是指针。

``` c++
int *p[10];//声明一个指针数组，该数组有10个元素，其中每个元素都是一个指向int类型的指针
```

在上述声明中，由于 [] 的优先级比 * 高，故 p 先与 [] 结合，成为一个数组 p[]；再由 int * 指明这是一个 int 类型的指针数组，数组中的元素都是 int 类型的指针。数组的第 i 个元素是 \*p[i]，而 p[i] 是一个指针。由于指针数组中存放着多个指针，操作灵活，在一些需要操作大量数据的程序中使用，可以使程序更灵活快速。

#### 数组指针

数组指针是一个指针，它指向一个数组。

``` c++
int a[5],b[3][10];
int *p1=a;//声明一个一维数组指针 p1，本语句也可写为 int *p1=&a[0]，两者是等价的
int (*p2)[10];//声明一个二维数组指针 p2，该指针指向一个二维数组，b[x][10]
p2=b;
```
关于上面提到的二维指针，由于 () 的优先级最高，所以 p 是一个指针，指向一个 int 类型的一维数组，这个一维数组的长度是 10，这也是指针 p 的**步长**。也就是说，执行 p+1 时，p 要跨过 n=10 个 int 型数据的长度。

### 结构体指针

这个知识点刚刚才学，先看看下面这段代码：

``` c++
struct student
{
	int id,score;
	char name[10];
};
student stu;
student *p=&stu;//声明一个结构体指针，该指针指向的类型为student
```
通常情况下，我们访问结构体成员的有以下表述：

``` c++
/*第2、3种为指针访问*/
stu.id stu.name
p->id p->name
(*p).id

void input(student *s,int n)
{
	for(int i=0;i<n;i++)
	{
		cin>>(s+i)->id>>(s+i)->name>>(s+i)->score;
		cin>>s[i].id>>s[i].name>>s[i].score;
		cin>>(*(s+i)).id>>(*(s+i)).name>>(*(s+i)).score;
		//以上三条语句等效
	}
}
```
### 指针与函数

``` c++
void swap(int *p1,int *p2)  
{  
	int temp=*p1;   
	*p1=*p2;   
	*p2=temp;
}

int main()
{
	int a=3,b=6; swap(&a,&b);//传入函数中指针参数的是地址
	cout<<"a="<<a<<" b="<<b<<endl;
	return 0;
}
```

### 函数指针

``` c++
#include<iostream>

using namespace std;

int get_Max(int a,int b)
{
    return a>b?a:b;
}

int main()
{
    int a=3,b=5,Max;
    int (*p)(int,int);
    p=get_Max;
    Max=p(a,b);
    return 0;
}
```

